<!DOCTYPE html>
<html>
<head>
    <title>Stream Capture Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100">
    <div class="container mx-auto p-4">
        <h1 class="text-2xl font-bold mb-4">Stream Capture Dashboard</h1>

        <div class="bg-white rounded-lg shadow p-4 mb-4">
            <h2 class="text-xl font-semibold mb-2">Start New Capture</h2>
            <form id="captureForm" class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700">Stream URL</label>
                    <input type="text" id="streamUrl" class="mt-1 block w-full rounded-md border border-gray-300 p-2" required>
                </div>
                <div class="flex justify-between items-center">
                    <button type="submit" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600" 
                            id="submitButton">
                        Start Capture
                    </button>
                    <div id="loadingIndicator" class="hidden">
                        <svg class="animate-spin h-5 w-5 text-blue-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                        <span class="ml-2">Starting capture...</span>
                    </div>
                </div>
            </form>
            <div id="errorMessage" class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded my-2 hidden"></div>
        </div>

        <div class="bg-white rounded-lg shadow p-4 mb-4">
            <h2 class="text-xl font-semibold mb-2">Active Captures</h2>
            <div id="activeCaptures" class="space-y-4"></div>
        </div>

        <template id="captureTemplate">
            <div class="border rounded-lg p-4 space-y-4 capture-item">
                <div class="flex justify-between items-start">
                    <div>
                        <h3 class="font-semibold">Stream URL: <span class="stream-url"></span></h3>
                        <p>ID: <span class="capture-id"></span></p>
                        <p>Status: <span class="status"></span></p>
                        <p>Duration: <span class="duration"></span></p>
                    </div>
                    <button class="stop-capture bg-red-500 text-white px-3 py-1 rounded hover:bg-red-600">Stop</button>
                </div>

                <div class="debug-info mt-4">
                    <h4 class="font-semibold mb-2">Debug Information</h4>

                    <div class="screenshot-gallery grid grid-cols-2 gap-4 mb-4">
                        </div>

                    <div class="page-analysis">
                        <h5 class="font-semibold">Page Elements Found:</h5>
                        <pre class="bg-gray-100 p-2 rounded mt-1 text-sm elements-found overflow-auto max-h-40"></pre>

                        <h5 class="font-semibold mt-2">Video Elements:</h5>
                        <pre class="bg-gray-100 p-2 rounded mt-1 text-sm video-elements overflow-auto max-h-40"></pre>
                    </div>

                    <div class="errors mt-4">
                        <h5 class="font-semibold text-red-600">Errors:</h5>
                        <pre class="bg-red-50 p-2 rounded mt-1 text-sm error-list"></pre>
                    </div>
                </div>
            </div>
        </template>
    </div>

    <script>
        class CaptureError extends Error {
            constructor(message, status) {
                super(message);
                this.name = 'CaptureError';
                this.status = status;
            }
        }

        function showError(message, temporary = true) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.textContent = message;
            errorDiv.classList.remove('hidden');
            if (temporary) {
                setTimeout(() => errorDiv.classList.add('hidden'), 5000);
            }
        }

        let activeStreams = new Set(); // Keep track of active stream IDs

        const POLL_INTERVAL = 2000; // 2 seconds
        const MAX_RETRIES = 3;

        async function pollCaptureStatus(streamId, retryCount = 0) {
            if (!activeStreams.has(streamId)) return;
            
            try {
                await updateCaptureElement(streamId);
                setTimeout(() => pollCaptureStatus(streamId), POLL_INTERVAL);
            } catch (error) {
                if (retryCount < MAX_RETRIES) {
                    setTimeout(() => pollCaptureStatus(streamId, retryCount + 1), 
                        POLL_INTERVAL * (retryCount + 1));
                } else {
                    showError(`Failed to update capture ${streamId}: ${error.message}`);
                    activeStreams.delete(streamId);
                }
            }
        }

        // --- Start a new capture ---
        document.getElementById('captureForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const submitButton = document.getElementById('submitButton');
            const loadingIndicator = document.getElementById('loadingIndicator');
            
            try {
                submitButton.disabled = true;
                loadingIndicator.classList.remove('hidden');
                
                const streamUrl = document.getElementById('streamUrl').value;
                const response = await fetch('/streams/start', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify({ stream_url: streamUrl })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new CaptureError(
                        errorData.error || 'Failed to start capture',
                        response.status
                    );
                }

                const data = await response.json();
                createCaptureElement(data);
                activeStreams.add(data.id);
                pollCaptureStatus(data.id);
                document.getElementById('streamUrl').value = '';
                
            } catch (error) {
                showError(`Error starting capture: ${error.message}`);
            } finally {
                submitButton.disabled = false;
                loadingIndicator.classList.add('hidden');
            }
        });

        // --- Create a new capture element ---
        function createCaptureElement(data) {
            const template = document.getElementById('captureTemplate');
            const clone = template.content.cloneNode(true);

            // Set initial data (stream URL,  ID, initial status)
            clone.querySelector('.stream-url').textContent = data.stream_url;
            clone.querySelector('.capture-id').textContent = data.id; // Initially, this is the *task* ID
            clone.querySelector('.status').textContent = data.status || 'Starting...';
            clone.querySelector('.duration').textContent = data.duration || ''; // Initially empty

            // Add stop button handler
            const stopBtn = clone.querySelector('.stop-capture');
            stopBtn.addEventListener('click', () => stopCapture(data.id));


            const container = document.getElementById('activeCaptures');
            const captureDiv = document.createElement('div');
            captureDiv.setAttribute('data-capture-id', data.id); // Set data-capture-id to stream ID
            captureDiv.appendChild(clone);
            container.insertBefore(captureDiv, container.firstChild); // Add to the top
        }


       // --- Update the capture element with new data ---
       async function updateCaptureElement(streamId) {
            // Find element by stream ID
            const captureDiv = document.querySelector(`[data-capture-id="${streamId}"]`);

            if (!captureDiv) {
                console.warn(`Could not find capture element to update. Stream ID: ${streamId}`);
                return;
            }

           // Fetch the latest status
            try {
                const response = await fetch(`/streams/status/${streamId}`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                // Update status and duration
                captureDiv.querySelector('.status').textContent = data.status;
                captureDiv.querySelector('.duration').textContent = data.duration || 'In progress';


                // Update screenshots (if available)
                const gallery = captureDiv.querySelector('.screenshot-gallery');
                gallery.innerHTML = ''; // Clear existing
                if (data.debug_screenshots && data.debug_screenshots.length > 0) {
                    data.debug_screenshots.forEach(screenshot => {
                      const timestamp = screenshot.split('/').pop().split('_')[1].split('.')[0]; // More robust
                        const img = document.createElement('div');
                        img.className = 'screenshot-container';
                        img.innerHTML = `
                            <p class="text-sm font-medium mb-1">Screenshot at ${timestamp}</p>
                            <img src="/streams/debug/${data.id}/screenshots/${timestamp}"
                                class="w-full h-auto rounded shadow"
                                alt="Screenshot ${timestamp}">
                        `;
                        gallery.appendChild(img);
                    });
                }

                // Update page analysis (if available)
                if (data.page_analysis) {
                    const elementsPre = captureDiv.querySelector('.elements-found');
                    elementsPre.textContent = JSON.stringify(data.page_analysis.elements || [], null, 2);

                    const videoPre = captureDiv.querySelector('.video-elements');
                    videoPre.textContent = JSON.stringify(data.page_analysis.video_elements || [], null, 2);
                }

                // Update errors (if any)
                const errorsPre = captureDiv.querySelector('.error-list');
                errorsPre.textContent = data.errors && data.errors.length > 0 ?
                    JSON.stringify(data.errors, null, 2) :
                    'No errors reported';

                 // Add download link if capture is completed
                const actionContainer = captureDiv.querySelector('.capture-item > div');
                if (data.status === 'completed' && data.video_path) {
                    if(!actionContainer.querySelector('.download-link')){
                        const link = document.createElement('a');
                        link.href = `/streams/download/${data.id}`;
                        link.className = 'download-link bg-green-500 text-white px-3 py-1 rounded hover:bg-green-600 ml-2';
                        link.textContent = 'Download Video';
                        actionContainer.appendChild(link);
                    }

                }


            }
            catch (error) {
                console.error('Error updating capture element:', error);
                 captureDiv.querySelector('.status').textContent = "Error updating status";
                 document.getElementById('errorMessage').textContent = `Error updating status: ${error.message}`;
                 document.getElementById('errorMessage').classList.remove('hidden');
            }

        }

        // --- Stop capture ---
        async function stopCapture(id) {
            if (!confirm('Are you sure you want to stop this capture?')) {
                return;
            }

            const captureDiv = document.querySelector(`[data-capture-id="${id}"]`);
            const stopButton = captureDiv.querySelector('.stop-capture');
            stopButton.disabled = true;
            stopButton.textContent = 'Stopping...';

            try {
                // Change this line
                const response = await fetch(`/streams/stop/${id}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                    // No need to send the ID in the body since it's in the URL
                });

                const data = await response.json();
                if (!response.ok) {
                    throw new CaptureError(data.error || 'Failed to stop capture', response.status);
                }

                captureDiv.remove();
                activeStreams.delete(id);
            } catch (error) {
                showError(`Error stopping capture: ${error.message}`);
                stopButton.disabled = false;
                stopButton.textContent = 'Stop';
            }
        }

    </script>
</body>
</html>