<!DOCTYPE html>
<html>
<head>
    <title>Stream Capture Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100">
    <div class="container mx-auto p-4">
        <h1 class="text-2xl font-bold mb-4">Stream Capture Dashboard</h1>

        <div class="bg-white rounded-lg shadow p-4 mb-4">
            <h2 class="text-xl font-semibold mb-2">Start New Capture</h2>
            <form id="captureForm" class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700">Stream URL</label>
                    <input type="text" id="streamUrl" class="mt-1 block w-full rounded-md border border-gray-300 p-2" required>
                </div>
                <div class="flex justify-between items-center">
                    <button type="submit" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">Start Capture</button>
                    <div id="timeoutTimer" class="hidden">
                        <span class="font-medium text-orange-600">Timeout in: </span>
                        <span id="timerValue" class="font-bold text-orange-600">60</span>
                        <span class="text-orange-600"> seconds</span>
                    </div>
                </div>
            </form>
            <div id="errorMessage" class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded my-2 hidden"></div>
        </div>

        <div class="bg-white rounded-lg shadow p-4 mb-4">
            <h2 class="text-xl font-semibold mb-2">Active Captures</h2>
            <div id="activeCaptures" class="space-y-4"></div>
        </div>

        <template id="captureTemplate">
            <div class="border rounded-lg p-4 space-y-4 capture-item">
                <div class="flex justify-between items-start">
                    <div>
                        <h3 class="font-semibold">Stream URL: <span class="stream-url"></span></h3>
                        <p>ID: <span class="capture-id"></span></p>
                        <p>Status: <span class="status"></span></p>
                        <p>Duration: <span class="duration"></span></p>
                    </div>
                    <button class="stop-capture bg-red-500 text-white px-3 py-1 rounded hover:bg-red-600">Stop</button>
                </div>

                <div class="debug-info mt-4">
                    <h4 class="font-semibold mb-2">Debug Information</h4>

                    <div class="screenshot-gallery grid grid-cols-2 gap-4 mb-4">
                        </div>

                    <div class="page-analysis">
                        <h5 class="font-semibold">Page Elements Found:</h5>
                        <pre class="bg-gray-100 p-2 rounded mt-1 text-sm elements-found overflow-auto max-h-40"></pre>

                        <h5 class="font-semibold mt-2">Video Elements:</h5>
                        <pre class="bg-gray-100 p-2 rounded mt-1 text-sm video-elements overflow-auto max-h-40"></pre>
                    </div>

                    <div class="errors mt-4">
                        <h5 class="font-semibold text-red-600">Errors:</h5>
                        <pre class="bg-red-50 p-2 rounded mt-1 text-sm error-list"></pre>
                    </div>
                </div>
            </div>
        </template>
    </div>

    <script>
        let activeStreams = new Set(); // Keep track of active streams/tasks (using task IDs initially)
        let timeoutTimer;

        function startTimer() {
            const timerDiv = document.getElementById('timeoutTimer');
            const timerValue = document.getElementById('timerValue');
            let timeLeft = 60;

            timerDiv.classList.remove('hidden');
            timerValue.textContent = timeLeft;

            timeoutTimer = setInterval(() => {
                timeLeft--;
                timerValue.textContent = timeLeft;

                if (timeLeft <= 10) {
                    timerValue.classList.add('text-red-600');
                    timerValue.classList.remove('text-orange-600');
                }

                if (timeLeft <= 0) {
                    clearInterval(timeoutTimer);
                }
            }, 1000);
        }

        function stopTimer() {
            if (timeoutTimer) {
                clearInterval(timeoutTimer);
                document.getElementById('timeoutTimer').classList.add('hidden');
                document.getElementById('timerValue').classList.remove('text-red-600');
                document.getElementById('timerValue').classList.add('text-orange-600');
            }
        }


        // --- Start a new capture (Initiates the Celery task) ---
        document.getElementById('captureForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const streamUrl = document.getElementById('streamUrl').value;
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.classList.add('hidden');
            stopTimer(); // Clear any existing timer
            startTimer(); // Start new timer

            try {
                const response = await fetch('/streams/start', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json' // Added for clarity
                    },
                    body: JSON.stringify({ stream_url: streamUrl })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
                }

                const data = await response.json(); // Expecting { task_id: "...", status: "pending" }
                console.log('Response data (start):', data); // Log the response

                if (data.task_id) {
                    // Create a placeholder element with the task ID.  This is where the *initial* status will go.
                    createCaptureElement({ id: data.task_id, stream_url: streamUrl, status: data.status || 'Pending...' });  // Provide initial status
                    activeStreams.add(data.task_id); // Add the *task ID* to activeStreams
                    pollTaskStatus(data.task_id); // Start polling for task status
                    stopTimer(); // Stop timer on success
                } else {
                    throw new Error("Did not receive a task ID from the server.");
                }

            } catch (error) {
                console.error('Error starting capture:', error);
                errorDiv.textContent = `Error: ${error.message}`;
                errorDiv.classList.remove('hidden');
                stopTimer(); // Stop timer
            }
        });


        // --- Create a new capture element (Initially with limited info) ---
        function createCaptureElement(data) {
            const template = document.getElementById('captureTemplate');
            const clone = template.content.cloneNode(true);

            // Set initial data (stream URL, task ID, initial status)
            clone.querySelector('.stream-url').textContent = data.stream_url;
            clone.querySelector('.capture-id').textContent = data.id; // Initially, this is the *task* ID
            clone.querySelector('.status').textContent = data.status || 'Pending...';
            clone.querySelector('.duration').textContent = data.duration || ''; // Initially empty

            // Add stop button handler (IMPORTANT: We'll update the ID later)
            const stopBtn = clone.querySelector('.stop-capture');
            stopBtn.addEventListener('click', () => stopCapture(data.id));


            const container = document.getElementById('activeCaptures');
            const captureDiv = document.createElement('div');
            captureDiv.setAttribute('data-capture-id', data.id); // Set data-capture-id to task ID
            captureDiv.appendChild(clone);
            container.insertBefore(captureDiv, container.firstChild); // Add to the top
        }


        // --- Update the capture element with new data (from polling) ---
        function updateCaptureElement(data) {
            // 1. Try to find the element by task_id (initial state)
            let captureDiv = document.querySelector(`[data-capture-id="${data.task_id}"]`);

            // 2. If found by task_id, and we now have a stream_id, update the data-capture-id
            if (captureDiv && data.id) {
                captureDiv.setAttribute('data-capture-id', data.id);
            }

            // 3. If not found by task_id (or we just updated it), try to find by stream_id
            captureDiv = document.querySelector(`[data-capture-id="${data.id}"]`);


            if (!captureDiv) {
                console.warn(`Could not find capture element to update. Task ID: ${data.task_id}, Stream ID: ${data.id}`); // More specific warning
                return;
            }

            // Update status (use data.state for Celery state, data.status for capture status)
            captureDiv.querySelector('.status').textContent = data.status || data.state || 'Unknown';

             if (data.duration) {
                captureDiv.querySelector('.duration').textContent = data.duration;
            }


            // Update screenshots (if available)
            const gallery = captureDiv.querySelector('.screenshot-gallery');
            gallery.innerHTML = ''; // Clear existing
            if (data.debug_screenshots && data.debug_screenshots.length > 0) {
                data.debug_screenshots.forEach(screenshot => {
                    const timestamp = screenshot.split('/').pop().split('_')[1].split('.')[0]; // More robust timestamp extraction
                    const img = document.createElement('div');
                    img.className = 'screenshot-container';
                    img.innerHTML = `
                        <p class="text-sm font-medium mb-1">Screenshot at ${timestamp}</p>
                        <img src="/streams/debug/${data.id}/screenshots/${timestamp}"
                             class="w-full h-auto rounded shadow"
                             alt="Screenshot ${timestamp}">
                    `;
                    gallery.appendChild(img);
                });
            }

            // Update page analysis (if available)
            if (data.page_analysis) {
                const elementsPre = captureDiv.querySelector('.elements-found');
                elementsPre.textContent = JSON.stringify(data.page_analysis.elements || [], null, 2);

                const videoPre = captureDiv.querySelector('.video-elements');
                videoPre.textContent = JSON.stringify(data.page_analysis.video_elements || [], null, 2);
            }

            // Update errors (if any)
            const errorsPre = captureDiv.querySelector('.error-list');
            errorsPre.textContent = data.errors && data.errors.length > 0 ?
                JSON.stringify(data.errors, null, 2) :
                'No errors reported';
        }


        // --- Poll for task status ---
        async function pollTaskStatus(taskId) {

            if (!activeStreams.has(taskId)) {
                console.log(`Task ${taskId} is no longer active.  Stopping polling.`); // Debugging log
                return; // Stop if task ID removed
            }


            try {
                const response = await fetch(`/streams/status/${taskId}`); // CORRECT URL
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                console.log("poll data", data)

                if (data.state === 'SUCCESS') {
                    // Task succeeded:  Now we have the *stream capture* data
                    activeStreams.delete(taskId); // Remove the *task* ID
                    activeStreams.add(data.id); // Add the *stream* ID
                    updateCaptureElement(data); // Update with full capture details
                } else if (data.state === 'FAILURE') {
                    // Task failed
                    console.error("Task failed:", data.status); // Log the error
                    updateCaptureElement({ task_id: taskId, status: 'Failed', errors: [data.status] }); // Show error
                    activeStreams.delete(taskId);  // Remove task ID on failure
                } else {
                    // Task is still pending or in progress...
                    updateCaptureElement({ task_id: taskId, status: data.status || data.state }); // Show "Pending..." or "Running..."
                    setTimeout(() => pollTaskStatus(taskId), 2000); // Poll again in 2 seconds
                }
            } catch (error) {
                console.error('Error polling task status:', error);
                // Consider stopping polling on error, or showing an error message.
                 updateCaptureElement({ task_id: taskId, status: 'Error', errors: [error.message] });
            }
        }


        // --- Stop capture (Sends request to stop the *capture*, not the task) ---
        async function stopCapture(id) {
           // Now id could be a task ID *or* a stream ID.  We handle both.
           console.log("Stopping capture with ID:", id);  // Debug log


            try {
                const response = await fetch('/streams/stop', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ stream_id: id }) // Send stream_id
                });

                 const data = await response.json();

                if (response.ok) {
                    // No need to update, as routes.py deletes
                    // Find and remove the element
                    const captureDiv = document.querySelector(`[data-capture-id="${id}"]`);
                    if (captureDiv) {
                         captureDiv.remove();
                         }
                } else {
                     throw new Error(data.error || 'Failed to stop capture');
                }


                // Remove from activeStreams, regardless of whether it's a task ID or stream ID
                activeStreams.delete(id);


            } catch (error) {
                console.error('Error stopping capture:', error);
            }
        }

    </script>
</body>
</html>