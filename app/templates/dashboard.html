<!DOCTYPE html>
<html>
<head>
    <title>Stream Capture Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100">
    <div class="container mx-auto p-4">
        <h1 class="text-2xl font-bold mb-4">Stream Capture Dashboard</h1>

        <!-- Start Capture Form -->
        <div class="bg-white rounded-lg shadow p-4 mb-4">
            <h2 class="text-xl font-semibold mb-2">Start New Capture</h2>
            <form id="captureForm" class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700">Stream URL</label>
                    <input type="text" id="streamUrl" class="mt-1 block w-full rounded-md border border-gray-300 p-2" required>
                </div>
                <div class="flex justify-between items-center">
                    <button type="submit" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">Start Capture</button>
                    <div id="timeoutTimer" class="hidden">
                        <span class="font-medium text-orange-600">Timeout in: </span>
                        <span id="timerValue" class="font-bold text-orange-600">60</span>
                        <span class="text-orange-600"> seconds</span>
                    </div>
                </div>
            </form>
            <div id="errorMessage" class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded my-2 hidden"></div>
        </div>

        <!-- Active Captures -->
        <div class="bg-white rounded-lg shadow p-4 mb-4">
            <h2 class="text-xl font-semibold mb-2">Active Captures</h2>
            <div id="activeCaptures" class="space-y-4"></div>
        </div>

        <!-- Capture Details Template (Hidden) -->
        <template id="captureTemplate">
            <div class="border rounded-lg p-4 space-y-4 capture-item">
                <div class="flex justify-between items-start">
                    <div>
                        <h3 class="font-semibold">Stream URL: <span class="stream-url"></span></h3>
                        <p>ID: <span class="capture-id"></span></p>
                        <p>Status: <span class="status"></span></p>
                        <p>Duration: <span class="duration"></span></p>
                    </div>
                    <button class="stop-capture bg-red-500 text-white px-3 py-1 rounded hover:bg-red-600">Stop</button>
                </div>

                <!-- Debug Info -->
                <div class="debug-info mt-4">
                    <h4 class="font-semibold mb-2">Debug Information</h4>
                    
                    <!-- Screenshots -->
                    <div class="screenshot-gallery grid grid-cols-2 gap-4 mb-4">
                        <!-- Screenshots will be inserted here -->
                    </div>

                    <!-- Page Analysis -->
                    <div class="page-analysis">
                        <h5 class="font-semibold">Page Elements Found:</h5>
                        <pre class="bg-gray-100 p-2 rounded mt-1 text-sm elements-found overflow-auto max-h-40"></pre>
                        
                        <h5 class="font-semibold mt-2">Video Elements:</h5>
                        <pre class="bg-gray-100 p-2 rounded mt-1 text-sm video-elements overflow-auto max-h-40"></pre>
                    </div>

                    <!-- Errors -->
                    <div class="errors mt-4">
                        <h5 class="font-semibold text-red-600">Errors:</h5>
                        <pre class="bg-red-50 p-2 rounded mt-1 text-sm error-list"></pre>
                    </div>
                </div>
            </div>
        </template>
    </div>

    <script>
        let activeStreams = new Set();
        let timeoutTimer;
        
        function startTimer() {
            const timerDiv = document.getElementById('timeoutTimer');
            const timerValue = document.getElementById('timerValue');
            let timeLeft = 60;
            
            timerDiv.classList.remove('hidden');
            timerValue.textContent = timeLeft;
            
            timeoutTimer = setInterval(() => {
                timeLeft--;
                timerValue.textContent = timeLeft;
                
                if (timeLeft <= 10) {
                    timerValue.classList.add('text-red-600');
                    timerValue.classList.remove('text-orange-600');
                }
                
                if (timeLeft <= 0) {
                    clearInterval(timeoutTimer);
                }
            }, 1000);
        }
        
        function stopTimer() {
            if (timeoutTimer) {
                clearInterval(timeoutTimer);
                document.getElementById('timeoutTimer').classList.add('hidden');
                document.getElementById('timerValue').classList.remove('text-red-600');
                document.getElementById('timerValue').classList.add('text-orange-600');
            }
        }

        // Start a new capture
        document.getElementById('captureForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const streamUrl = document.getElementById('streamUrl').value;
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.classList.add('hidden');
            stopTimer();  // Clear any existing timer
            startTimer();  // Start new timer
            
            try {
                console.log('Submitting with URL:', streamUrl);
                const response = await fetch('/streams/start', {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify({ stream_url: streamUrl })
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
                }
                
                const data = await response.json();
                console.log('Response data:', data);
                
                if (!activeStreams.has(data.id)) {
                    activeStreams.add(data.id);
                    createCaptureElement(data);
                    pollCaptureStatus(data.id);
                    stopTimer();  // Stop timer on successful capture
                }
            } catch (error) {
                console.error('Error starting capture:', error);
                errorDiv.textContent = `Error: ${error.message}`;
                errorDiv.classList.remove('hidden');
                stopTimer();  // Stop timer on error
            }
        });

        // Create new capture element
        function createCaptureElement(data) {
            const template = document.getElementById('captureTemplate');
            const clone = template.content.cloneNode(true);
            
            // Set initial data
            clone.querySelector('.stream-url').textContent = data.stream_url;
            clone.querySelector('.capture-id').textContent = data.id;
            clone.querySelector('.status').textContent = data.status;
            clone.querySelector('.duration').textContent = data.duration || 'In progress';
            
            // Add stop button handler
            const stopBtn = clone.querySelector('.stop-capture');
            stopBtn.addEventListener('click', () => stopCapture(data.id));
            
            // Add to active captures
            const container = document.getElementById('activeCaptures');
            const captureDiv = document.createElement('div');
            captureDiv.setAttribute('data-capture-id', data.id);
            captureDiv.appendChild(clone);
            container.insertBefore(captureDiv, container.firstChild);
        }

        // Update capture element with new data
        function updateCaptureElement(data) {
            const captureDiv = document.querySelector(`[data-capture-id="${data.id}"]`);
            if (!captureDiv) return;

            // Update basic info
            captureDiv.querySelector('.status').textContent = data.status;
            captureDiv.querySelector('.duration').textContent = data.duration || 'In progress';

            // Update screenshots
            const gallery = captureDiv.querySelector('.screenshot-gallery');
            gallery.innerHTML = ''; // Clear existing
            
            if (data.debug_screenshots && data.debug_screenshots.length > 0) {
                data.debug_screenshots.forEach(screenshot => {
                    // Extract timestamp from filename
                    const timestamp = screenshot.split('/').pop().split('_')[0];
                    const img = document.createElement('div');
                    img.className = 'screenshot-container';
                    img.innerHTML = `
                        <p class="text-sm font-medium mb-1">Screenshot at ${timestamp}</p>
                        <img src="/streams/debug/${data.id}/screenshots/${timestamp}" 
                             class="w-full h-auto rounded shadow" 
                             alt="Screenshot ${timestamp}">
                    `;
                    gallery.appendChild(img);
                });
            }

            // Update page analysis
            if (data.page_analysis) {
                const elementsPre = captureDiv.querySelector('.elements-found');
                elementsPre.textContent = JSON.stringify(data.page_analysis.elements || [], null, 2);

                const videoPre = captureDiv.querySelector('.video-elements');
                videoPre.textContent = JSON.stringify(data.page_analysis.video_elements || [], null, 2);
            }

            if (data.bot_detection && data.bot_detection.found_measures.length > 0) {
                const detectionInfo = document.createElement('div');
                detectionInfo.className = 'mt-4 p-2 bg-yellow-100 rounded';
                detectionInfo.innerHTML = `
                    <h5 class="font-semibold">Bot Detection Found:</h5>
                    <ul class="list-disc pl-4">
                        ${data.bot_detection.found_measures.map(m => `<li>${m}</li>`).join('')}
                    </ul>
                `;
                captureDiv.querySelector('.debug-info').appendChild(detectionInfo);
            }
        
            // Update errors
            const errorsPre = captureDiv.querySelector('.error-list');
            errorsPre.textContent = data.errors.length ? 
                JSON.stringify(data.errors, null, 2) : 
                'No errors reported';
        }

        // Poll for status updates
        async function pollCaptureStatus(id) {
            try {
                const response = await fetch(`/streams/debug/${id}`);
                const data = await response.json();
                
                updateCaptureElement(data);
                
                // Continue polling if not completed
                if (data.status !== 'completed' && activeStreams.has(id)) {
                    setTimeout(() => pollCaptureStatus(id), 2000);
                } else {
                    activeStreams.delete(id);
                }
            } catch (error) {
                console.error('Error polling status:', error);
            }
        }

        // Stop capture
        async function stopCapture(id) {
            try {
                const response = await fetch('/streams/stop', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ stream_id: id })
                });
                
                const data = await response.json();
                updateCaptureElement(data);
                activeStreams.delete(id);
            } catch (error) {
                console.error('Error stopping capture:', error);
            }
        }
    </script>
</body>
</html>